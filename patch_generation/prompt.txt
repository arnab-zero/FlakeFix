You are an expert at fixing asynchronous flaky tests using STATIC call-boundary synchronization with COMPLETION semantics.

INPUT
You will receive ONE JSON object containing:
- test_method: { class_name, name, file_path, location.start_line/end_line, body.lines }
- calls: methods invoked by the test up to 2 hops, each with:
  { class_name, name, full_qualified_name, file_path, location.start_line/end_line, body.lines, calls[] }

GOAL
Generate patches so that whenever a caller method A invokes an asynchronous method B, method A waits (at the call boundary) until the asynchronous work launched by B has COMPLETED.

KEY RULES (MUST FOLLOW)
1) No injected delays, no reruns, no stack traces: use only the JSON.
2) COMPLETION MODE (Mode C):
   - Your synchronization must ensure A waits until B’s async work finishes at a clear endpoint.
3) Barrier placement:
   - Insert the barrier IMMEDIATELY AFTER the call to B, before the next line in A executes:
     B.callAsync(...);
     while (!B.getCompletedStatus()) { Thread.yield(); }
4) Patches allowed on both sides (A and B).
5) One synchronization per async call site (assume B is not called many times).

HOW TO FIND ASYNC B (STATIC DETECTION)
Mark a method as async if its body includes any of:
- executor submission: submit/execute/schedule
- timers: setTimer
- async callbacks: onSuccess/onFailure/listeners
- Future.future(...) or promise-based async

HOW TO FIND COMPLETION ENDPOINT IN B
Because Mode C is required, you must locate completion endpoints inside B’s async runnable/callback.
Treat these as completion endpoints (ranked):
1) promise.complete(...) / promise.fail(...)
2) future.complete(...) / completeExceptionally(...)
3) context.complete()
4) other obvious “final step” lines in the async callback
You must set completion status to true on ALL terminal branches (e.g., success and failure) to avoid infinite waiting.

PATCH STRUCTURE (REQUIRED)
Production-side (in B’s owning class):
- Add: `private static volatile boolean hasCompleted;`
- Add test-only methods:
  - `public static void reset() { hasCompleted = false; }`   // test-only
  - `public static boolean getCompletedStatus() { return hasCompleted; }` // test-only
- Insert: `hasCompleted = true;` at the completion endpoint(s) inside the async runnable/callback.

Caller-side (in A, usually the test):
- Insert `<OwningClassOfB>.reset();` as the first executable line of A (or immediately before the async call if needed).
- Immediately after the async call site A→B, insert:
  while (!<OwningClassOfB>.getCompletedStatus()) { Thread.yield(); }

PROHIBITIONS
- Do NOT add Thread.sleep.
- Do NOT add timeouts to the yield loop.
- Do NOT replace the approach with CountDownLatch/CompletableFuture/locks.
- Do NOT invent files/classes not present in the JSON.

OUTPUT (MUST INCLUDE)
IMPORTANT: Provide ONLY the patch output below. Do NOT include any thinking, reasoning, or analysis process in your response. Start directly with section A.

A) Identified async boundary:
   - Specify which edge you patched (A→B or B→C), with file paths.

B) Patch Plan with exact locations:
   For each patch, provide:
   - file_path, class_name, method_name
   - insertion anchors (1–2 nearby lines)
   - insertion line numbers computed as:
     line = method.location.start_line + index_in_body_lines
     If inserting between lines, report the line number of the line immediately AFTER your insertion.

C) Code patches (edited snippets only):
   - Production class: hasCompleted field, inserted hasCompleted=true at completion endpoint(s),
     reset() and getCompletedStatus() methods with “test-only” comments.
   - Caller method: inserted reset call + infinite yield loop immediately after the async call.

NOW APPLY THIS TO THE FOLLOWING JSON:
<PASTE JSON HERE>